#include <iostream>


//практика на примере массива инт элементов.

int main()
{
	const int N = 11;
	int num_1[N] = { 1,2,3,4,5,6,7,8,9,10,11 };
	int num_2[N] = { 0 };

	const long long* p1 = (const long long*)num_1; //берем указатель на массив. Указатель, который указывает на тип данных лонг лонг\
													это значит, что по адрессу, который лежит в переменной p1 лежит лонг лонг.\
													лонг лонг занимает в памяти 8 байт (инт 4). 
	long long* p2 = (long long*)num_2;
	int m = (sizeof(int) * N) / sizeof(long long); //сейчас в p1 и в p2 лежат указатели на начало массива. Но так как мы привели массив\
													к указателю на тип лонг лонг, то сдвигая указатель (оператором p++), мы сместимся в\
													в памяти на 8 байт (вместо 4, если был бы инт и если бы приравнивали каждый элемент массива\
													отдельно). И разименовывая указатель p1 (из которого мы копируем) и разименовывая указатель\
													p2 (куда копируем), так как оба указателя указывают на тип лонг лонг, мы копируем\
													в адрес p2 (то есть туда же, где наш второй массив) 8 байтов. И смещаемся по указателю\
													так же на размер типа лонг лонг (8 байт). Так как массив состоит из инт элементов,\
													которые занимают в памяти 4 байта, то сам массив рассматривает элементы по 4 байта\
													а мы приравнивали по 8. То есть в два раза меньше операций, чем если бы a[i]=b[i]

	for (int i = 0; i < m; i++) {			//число м, это сколько "влезает" лонг лонг (8 байт) в объем памяти, занимаемый интовым массивом\
											то есть например 10 элементов массива занимают 40 байт\
											в 40 байт "влазит" 5 раз по 8 байт. То есть мы приравняем то, что лежит в указателе\
											(8 байт) всего 5 раз. Вместо 10, если бы копировали a[i]=b[i]
		*(p2++) = *(p1++);
	}	

	const char* another_type_p1 = (char*)p1;	//а тут мы копируем "остатки". Суть такая же. Если у нас массив из 11 элементов, то\
												44 байта/8 байтов=5 целых раз по 8 "входит" (скопировали в предыдущем пункте)\
												остаток=4. 4 раза копируем побайтово. Заметно эфективнее так копировать,\
												когда массив у нас состоит из четного количества элементов. Тогда копирований будет в 2\
												раза меньше. 
	char* another_type_p2 = (char*)p2;

	m = (sizeof(int) * N) % sizeof(long long);
	for (int i = 0; i < m; i++) {
		*(another_type_p2++) = *(another_type_p1++);
	}

	for (int i = 0; i < N; i++) {
		std::cout << num_2[i]<<" ";
	}













}


